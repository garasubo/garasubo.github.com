---
title: "UEFIアプリケーションをRustで書く（外部クレートなし）"
pubDate: "2019-03-30"
tags: ["rust", "uefi"]
description: "外部クレートを使わずにRustでUEFIアプリケーションを開発する手法"
---

このあいだのRustのアップデートで、`x86_64-unknown-uefi`なるターゲットが追加された、と聞いてRustでUEFIプログラミングに挑戦しました。
なお、世の中にはすでに[uefi-rs](https://github.com/rust-osdev/uefi-rs)というものが用意されているので、もっと簡単にUEFIアプリケーションを書くことができます。
ただ、このクレートの構造の説明みたいなのがドキュメントとして見当たらず、今までUEFIを触ったことがなかったので、せっかくなのでこのクレートも含め外部クレートなしでのプログラミングをしました。

## UEFIとは
BIOSに代わるファームウェアに対するソフトウェアインターフェースのこと。詳しくは[Wikipedia](https://ja.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface)ないし、C言語を使っての開発についてはもっと多くの先例があるのでそちらを参考にすればいいと思われる。

- [gnu-efiでUEFI遊びをはじめよう - Qiita](https://qiita.com/tnishinaga/items/40755f414557faf45dcb)
- [ツールキットを使わずに UEFI アプリケーションの Hello World! を作る - 品川高廣（東京大学）のブログ](http://d.hatena.ne.jp/shina_ecc/20140819/1408434995)
- [フルスクラッチで作る!UEFIベアメタルプログラミング](http://yuma.ohgami.jp/UEFI-Bare-Metal-Programming/)

最新の仕様は直接仕様書を見て確認しましょう。今回はversion 2.7に準拠。
[Unified Extensible Firmware Interface Forum](https://uefi.org/specifications)

## 準備
今回はx86\_64のUEFIアプリケーションをつくります。
まず、x86\_64ターゲットが追加されているRustを使う必要があります。また、ターゲットは追加されたものの、標準ライブラリ(stdではなくcoreとか)がまだ整えられていないのでstableではなくnightlyを使う必要があります。
更に、標準ライブラリを組み込むため[cargo-xbuild](https://github.com/rust-osdev/cargo-xbuild)も使う必要があります

```
$ rustup default nightly-2019-03-23
$ cargo install cargo-xbuild 
```

また、実行環境としてqemu-system-x86_64とqemu用のUEFIファームウェアである[OVMF](https://github.com/tianocore/tianocore.github.io/wiki/OVMF)が必要です。
自前でビルドする方法はやってみたのですが、途中で詰まってしまったし、めちゃくちゃ時間もかかるのでビルド済みのものをとってきたほうが早いでしょう
[https://www.kraxel.org/repos/](https://www.kraxel.org/repos/)からjenkins/edk2以下にあるx64用のrpmをとってきてその中にあるOVMF_VARS-pure-efi.fdとOVMF_CODE-pure-efi.fdをとってきました。

## できたもの
Githubに置いておきました。
[garasubo/uefi-practice](https://github.com/garasubo/uefi-practice)
`cargo xbuild --target x86_64-unknown-uefi`としてビルドし、qemu-run.shでqemu上で走らせます。ただし、OVMF_VARS.fdとOVMF_CODE.fdをプロジェクトのルートディレクトリに置いておく必要があります。

qemu-run.shを実行するとuefiシェルが立ち上がるので
```
Shell > fs0:
FS0: \> uefi-practice.efi
```
とすると、画面がクリアされた後、Hello Worldします

## 解説
`efi_main`関数がエントリポイントになっています。仕様書で言うと`EFI_IMAGE_ENTRY_POINT`に相当します。
仕様書にはC言語での型宣言が書かれているのですが、これをRustで書いていくことになります。
普通にstructやenumを宣言してしまうとRust独自のABIでコンパイルされてしまうので、`repr`をつけて互換性を保ちます。詳しくはThe Rustonomiconの[Data Layoutの章](https://doc.rust-lang.org/nomicon/data.html)が参考になります。
今回の目標はhello worldすることなのですが、UEFIのテキストを出力するためのインターフェースを利用します。
仕様書で言うと`EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL`です。
僕のコードではreset関数とoutput\_string関数が定義されていますが、本当はもっとあります。
他のstructについても今回は使う部分だけ型宣言をして残りはサボりました。使わない関数はusizeでごまかしました。全部実装するのはしんどい。

output\_stringはPROTOCOL自体へのポインタと文字列への先頭ポインタを渡す必要があります。この文字列が少々やっかいでUCS-2でエンコーディングされていないといけません。
RustはUTF-8で文字列を扱っているため、1文字が16ビットのUCS-2に変換するのは標準ライブラリだけで簡単にやってくれそうではなかったので、
適当なバッファを用意して、実行時に無理やり16ビット配列に変換しました(uefi-rsも内部ではそうやっていた)。

あとは`no_std`では`panic_handler`は自前で用意しなければならないのでそれも忘れずに。

## 疑問点
uefi-rsを参考にしながらつくったのだが、`extern "C"`と`extren "win64"`の両方が出てくることがあり、これの違いについてはよくわからなかった。
とりあえずuefi-rsに従いこれらの宣言をつけておいたが、本当は`extern "C"`としておいても問題ないかも？

## まとめ
UEFIの仕様は真面目に実装するのは大変なので、おとなしくuefi-rsを使いましょう

