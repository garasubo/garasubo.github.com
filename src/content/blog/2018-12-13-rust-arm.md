---
title: "RustでArm Cortex-Mプログラミングをする 2018"
pubDate: "2018-12-13"
tags: ["rust", "arm", "embedded"]
description: "2018年時点でのRustでのArm Cortex-Mプログラミングの現状と手法"
---
---

この記事は[自作OS Advent Calendar 2018](https://adventar.org/calendars/2915)および[Rust その2 Advent Calendar 2018](https://qiita.com/advent-calendar/2018/rust2)の記事です。

ベアメタルプログラミングといえばC言語であったが、C言語でプログラミングするのはつらい、ということでその代わりとなる言語としてRustが注目されてきている。
Rust+Armのベアメタルプログラミングに関しては[去年のRustアドベントカレンダーにも記事](https://qiita.com/tatsuya6502/items/7d8aaf3792bdb5b66f93)があったほか、自分も何件かすでにブログを書いているが、今年はRust Embeded Working Groupが発足し、資料も充実してきた（参考：[This Year in Embedded Rust](https://rust-embedded.github.io/blog/2018-11-14-this-year-in-embedded-rust/)）

## Rustでベアメタル
Rust Embeddedチームがすでにドキュメントをつくっているので（執筆中の章も存在するが）、これに従えば誰でもCortex-Mのベアメタルプログラミングできる
[The Embedded Rust Book](https://rust-embedded.github.io/book/)
ベースとなっているのはjaparic氏のブログなので、それの正式版と思ってもらえば良い。
チュートリアルはSTM32F3DISCOVERYをハードウェアと用いていて、[秋月電子通商](http://akizukidenshi.com/catalog/g/gM-06268/)などで日本でも2000円程度で手に入る。
以前、[QEMUで実行する方法](https://garasubo.github.io/hexo/2018/05/28/rust-qemu.html)もブログにしたが、タイマーなどの一部ペリフェラルが動かない他、やはりLEDが手元で光っている方が楽しいと思うので、がっつりとやりたいのなら実機の購入をおすすめする
一応、後述する通り他のcortex-mボードを用いても十分に開発できると思われる。現に僕はSTM社製の他のボードを使っている。


## cortex-m-quickstart
では実際にArm Cortex-Mでのベアメタルプログラミングの話に入ろうと思うのだが、
ベアメタルプログラミングするための手順だけであればThe Embedded Rust Bookがよくまとまっているので、それを読め、で終了してしまう。

なので今回はThe Embedded Rust Bookでも用いられている[cortex-m-quickstart](https://github.com/rust-embedded/cortex-m-quickstart)からサンプルコードを抜粋して大体なにをしているかを見ていくことにする。

### hello world
example/hello.rsを見てみよう。いわゆるhello worldである。
hprintln関数はセミホスティングを利用した出力を利用している。セミホスティングとはSVC命令などを利用することでデバッガに対してメッセージを送る機能である（参考:[https://developer.arm.com/products/software-development-tools/compilers/arm-compiler-5/docs/dui0471/f/semihosting/what-is-semihosting](https://developer.arm.com/products/software-development-tools/compilers/arm-compiler-5/docs/dui0471/f/semihosting/what-is-semihosting)）。
なので、UARTなどを利用したものでないため、本来ならデバッガをボードにつなぐ必要がある。が、DISCOVERYボードは基板にデバッガも内蔵しているので簡単に利用できる。

この`#[entry]`というアトリビュートがついたものが実質的なmain関数となる。ブートコードはどこにあるか、というとこのcortex-m-quickstartが依存しているライブラリの一つ、[cortex-m-rt](https://rust-embedded.github.io/cortex-m-rt/0.6.1/cortex_m_rt/index.html)が担っている。
このライブラリはビルド時のリンカスクリプトの生成もしていて、このアトリビュートをつけた関数を展開し、ブートのための処理を行った後呼び出す、という流れになっている。
大まかな仕組みとしてはライブラリに含まれるlink.x.inというスクリプトをベースに[build.rs](https://doc.rust-lang.org/cargo/reference/build-scripts.html)がスタックサイズのチェックや必要に応じて他のライブラリのリンカスクリプトを読み込んだりしている。
その他、例外発生時のハンドラの登録用マクロも用意されている。
詳しい仕組みはドキュメントを参照。

このテンプレートが依存しているもう一つのライブラリであるcortex-mライブラリはアセンブラ命令を呼び出すためのラッパやシステムレジスタの抽象化レイヤなどがふくまれている。
[インラインのアセンブラはまだ安定版ではないため](https://github.com/rust-lang/rust/issues/29722)、対応していない場合、予めコンパイルしてあるアセンブラを関数をextern Cで呼び出している
その際のArmのバージョンごとの違いはbuild.rsが指定されたターゲットを見てどのバイナリをリンクするかで吸収している。

### panic
example/panic.rsはpanicを発生させるだけのコードである。no_std環境でもpanicが発生した際の処理を実装しておかなければならない。
これは[最近安定化されたfeature](https://github.com/rust-lang/rust/issues/44489)のひとつでもある。
このサンプルコードではpanicハンドラを実装したクレートを読み込むことで動作を決定している。

### allocator
example/allocator.rsは自前で動的メモリ確保を実装することでno_std環境下でも動的配列を利用する例である。
基本的に組込みで動的メモリ確保は行わないほうがいいのだが、どうしても必要というケースは出てくる。
これも[最近安定化されたfeature](https://github.com/rust-lang/rust/issues/27389)のひとつでもある。
外部クレートで実装されたallocであるが、中身は空き領域をリスト形式で持っておき、要求に応じて空き領域リストを探索して返す、というシンプルなものになっている。
ただし、stdに含まれるvecは使えないので、allocクレート内のvecを使ってあげる必要がある。こちらはまだ[unstableなfeature](https://github.com/rust-lang/rfcs/pull/2480)。
allocクレートの中にはBoxやArcなど、所有権周りの問題を解決するのにおなじみの構造体も含まれている。

### device
マイコンのペリフェラルを使う例。stm32f103xxというクレートを使っているが、これはチップのMMIOのマッピングを記述したSVDファイルから[svd2rust](https://docs.rs/svd2rust/0.14.0/svd2rust/)を使って自動生成されたものである。
そのため、他のタイプのボードを使ってもSVDファイルさえ手に入れれば割と簡単に再現できる。
svd2rustはペリフェラルからの割り込みハンドラをリンクするためのcortex-m-rt用のリンカスクリプトもつくっている。
これはsvd2rustの生成したライブラリがCARGO\_FEATURE\_DEVICEというフラグをオンにすることで、device.xをcortex-m-rtが持つリンカスクリプトをインクルードさせている。



## その他の資料
Armではないが、RISC-V向けの記事が今年の自作OS Advent Calendarに上がってる
[RustでRISC-V OS自作！はじめの一歩](https://qiita.com/tomoyuki-nakabayashi/items/76f912adb6b7da6030c7)

また、以前も紹介したが、別のアプローチとしてTockという組込みOSが存在しており、そちらのデザインはなかなか工夫されている。
[Tock](https://www.tockos.org/)
ただし、こちらは専用ボード向けの実装しかないため、始めるにはハードルが高かったため、自分はまだ手が出ていない。

また、Cortex-Mではないが、Rasberry Pi 3でのチュートリアルも提供されている
[Bare Metal Rust Programming on Raspberry Pi 3](https://github.com/rust-embedded/rust-raspi3-tutorial)



