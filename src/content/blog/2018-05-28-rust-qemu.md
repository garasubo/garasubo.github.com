---
title: "Arm Cortex-MのRustベアメタルをQEMUでデバッグ"
pubDate: "2018-05-28"
tags: ["rust", "arm", "embedded"]
description: "ARM Cortex-MでのRustベアメタルプログラムをQEMUでデバッグする手法"
---
前回記事で紹介したTockのように、RustでもArmでのベアメタルプログラムができるようになってきた。
ベアメタルプログラミングで複雑なことをやろうとするとやはりエミュレータが欲しいな（以前、ハイパーバイザをつくった時はエミュレータなしでつらかった）、と思ったのでやってみた。

## STM32 Nucleo
省電力な組込み向けのアーキテクチャのCortex-MシリーズのMCU評価ボードは様々あるのだが、今回は[STM32 Nucleo](http://www.st.com/ja/evaluation-tools/stm32-mcu-nucleo.html?querycriteria=productId=LN1847)をターゲットとすることとした。
理由としては
- 以前、STM32 Discoveryを使用していたことがある
- 日本でも比較的安価な評価ボードが購入できる（3000円くらい）
- [Mbed](https://www.mbed.com/)に対応しているため、C/C++ベースではあるがサンプルコードが豊富なため


なお、Tockは独自の評価ボードを提供し、それを利用している。

## GNU MCU Eclipse QEMU
今回使うことにしたQEMUは本家のではなく、そのフォークである[GNU MCU Eclipse QEMU](https://gnu-mcu-eclipse.github.io/qemu/)を用いる。

参考: [QEMUでCortex-M3/M4マイコンボードをエミュレーションしてLチカする話](https://tnishinaga.hatenablog.com/entry/2016/12/31/130000)

Eclipseのプラグインのためのものであるが、コマンドラインから直接叩いて動かすのも可能。
本家QEMUより多くのボードをサポートしており、ボードの画像を表示してLチカのデバッグも可能なようだ。
[xpm](https://www.npmjs.com/package/xpm)を用いて簡単に導入することができる。

詳しい導入は[公式ドキュメント](https://gnu-mcu-eclipse.github.io/qemu/install/)に従えば良い。

## サンプルコードの入手
参考: [ARM Cortex-M 32ビットマイコンでベアメタル "Safe" Rust](https://qiita.com/tatsuya6502/items/7d8aaf3792bdb5b66f93)

今回動かしたコードはjaparic氏が提供している[cortex-m-quickstart](https://github.com/japaric/cortex-m-quickstart)を用いた。
参考にしたブログ記事は微妙に古いので[こちらのcrateのドキュメント](https://docs.rs/cortex-m-quickstart/0.3.1/cortex_m_quickstart/)を参照した。

## 実行
cortex-m-quickstartをドキュメント通りにビルドする。ただし、このQEMUはFPUのサポートがないため、targetはFPUなしのものを（hfで終わらないもの）を選ぶ必要がある。
生成物は`cargo build --release`の後、`target/thumbv7em-none-eabi/release`にできる。以下のようなシェルスクリプトを用意してQEMUを実行した。

{% codeblock qemu-system-gnuarmeclipse.sh lang:sh %}
#!/bin/sh

qemu_command=$HOME/opt/xPacks/@gnu-mcu-eclipse/qemu/2.8.0-3.1/.content/bin/qemu-system-gnuarmeclipse
board_name=NUCLEO-F411RE
mcu_name=STM32F411RE

$qemu_command \
--verbose --verbose --board $board_name --gdb tcp::3333 \
    --mcu $mcu_name -d unimp,guest_errors  \
    --image $1 \
    --semihosting-config enable=on,target=native \
    --semihosting-cmdline $1
{% endcodeblock %}
gdbのポートはcortex-m-quickstartの`.gdbinit`で3333になっているので3333を指定した。
実行結果は以下の通り。

{% codeblock %}
$ ./qemu-system-gnuarmeclipse.sh target/thumbv7em-none-eabi/release/cortex-m-quickstart

GNU MCU Eclipse 64-bits QEMU v2.8.0-3 (qemu-system-gnuarmeclipse).
Board: 'NUCLEO-F411RE' (ST Nucleo Development Board for STM32 F4 series).
Board picture: '/home/garasubo/opt/xPacks/@gnu-mcu-eclipse/qemu/2.8.0-3.1/.content/share/qemu/graphics/NUCLEO-F411RE.jpg'.
Device file: '/home/garasubo/opt/xPacks/@gnu-mcu-eclipse/qemu/2.8.0-3.1/.content/share/qemu/devices/STM32F411xx-qemu.json'.
Device: 'STM32F411RE' (Cortex-M4 r0p0, MPU, 4 NVIC prio bits, 86 IRQs), Flash: 512 kB, RAM: 128 kB.
Image: 'target/thumbv7em-none-eabi/release/cortex-m-quickstart'.
Command line: 'target/thumbv7em-none-eabi/release/cortex-m-quickstart' (54 bytes).
Load  16028 bytes at 0x08000000-0x08003E9B.
Cortex-M4 r0p0 core initialised.
'/machine/mcu/stm32/RCC', address: 0x40023800, size: 0x0400
'/machine/mcu/stm32/FLASH', address: 0x40023C00, size: 0x0400
'/machine/mcu/stm32/PWR', address: 0x40007000, size: 0x0400
'/machine/mcu/stm32/SYSCFG', address: 0x40013800, size: 0x0400
'/machine/mcu/stm32/EXTI', address: 0x40013C00, size: 0x0400
'/machine/mcu/stm32/GPIOA', address: 0x40020000, size: 0x0400
'/machine/mcu/stm32/GPIOB', address: 0x40020400, size: 0x0400
'/machine/mcu/stm32/GPIOC', address: 0x40020800, size: 0x0400
'/machine/mcu/stm32/GPIOD', address: 0x40020C00, size: 0x0400
'/machine/mcu/stm32/GPIOE', address: 0x40021000, size: 0x0400
'/machine/mcu/stm32/GPIOH', address: 0x40021C00, size: 0x0400
'/machine/mcu/stm32/USART1', address: 0x40011000, size: 0x0400
'/machine/mcu/stm32/USART2', address: 0x40004400, size: 0x0400
'/machine/mcu/stm32/USART6', address: 0x40011400, size: 0x0400
'/peripheral/led:green' 8*6 @(316,307) active high '/machine/mcu/stm32/GPIOA',5
'/peripheral/button:reset' 30*30 @(312,214)
'/peripheral/button:user' 30*30 @(204,219) active low '/machine/mcu/stm32/GPIOC',13
GDB Server listening on: 'tcp::3333'...
Cortex-M4 r0p0 core reset.

Hello, world!
^Cqemu-system-gnuarmeclipse: terminating on signal 2
{% endcodeblock %}

## Rust on baremetal Armの現状
cortex-m-quickstartの作者であるjapric氏はXargoをつくった人でもあり、かなり積極的にこの分野に貢献している人である。

{% raw %}
<blockquote class="twitter-tweet" data-lang="ja"><p lang="en" dir="ltr"><a href="https://twitter.com/rustlang?ref_src=twsrc%5Etfw">@rustlang</a>, stability without stagnation, taken to robotics<br><br>Probably the first WIP self-balancing robot coded in 100% Rust<a href="https://twitter.com/hashtag/RustyRobots?src=hash&amp;ref_src=twsrc%5Etfw">#RustyRobots</a> 1/ <a href="https://t.co/MGRPgKVCsS">pic.twitter.com/MGRPgKVCsS</a></p>&mdash; japaric @ Rustfest (@japaricious) <a href="https://twitter.com/japaricious/status/845697935572656128?ref_src=twsrc%5Etfw">2017年3月25日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
{% endraw %}

彼が今年初めに去年あったベアメタルArmのRustで起きたバグと今年の展望をまとめている。
[Embedded Rust in 2018 | Embedded in Rust](http://blog.japaric.io/embedded-rust-in-2018/)

現状、ベアメタルArmでプログラミングするためにはunstableなfeatureを使わざるを得ないため、完全に安定とは言えないものの、かなり状況はよくなってきているようだ。
