---
title: "X11環境でIMEの仮入力の情報を取得する"
pubDate: "2020-01-25"
tags: ["x11", "ime", "linux"]
description: "X11環境で日本語入力メソッドの仮入力情報をプログラムで取得する手法"
---

LinuxのX11向けのGUIアプリケーションでテキスト入力を扱いたい場合、IMEの存在を意識しなければならない（特に日本人ならば）。
IMEなしならば、キーボードイベントを見て、そのキーのアルファベットをプリントするだけで済むが、IMEが存在する場合、IMEから送られてくる文字列をきちんと処理する必要がある。
そのためには、X11のIMEフレームワークであるXIMの仕様を知る必要がある。

これらの仕様について解説し、実際のコードも紹介している記事はすでにある。
{% linkPreview https://tedyin.com/posts/a-brief-intro-to-linux-input-method-framework/ _blank %}

上記の記事を参考にしたと思われる日本語の記事もある。
{% linkPreview https://qiita.com/ai56go/items/63abe54f2504ecc940cd _blank %}

しかし、実はこれらの記事ではIME内で確定した文字列の情報しか取得しておらず、IME内でまだ確定していない仮入力状態の文字列（例えば変換前の元のひらがな）は取得できていない。
仮入力の文字列を取得できていないと、それらの文字列は当然描画できないし、例えば変換前の文字列を使った入力補完なんかも実装できない。
ある程度ちゃんとしたX11アプリケーションではこれらがちゃんとできていることからも想像がつく通り、XIMではこれらの状態を渡すインターフェースがある。

先述のブログのコードのうち、IMとの通信のためのコンテキスト構造体であるXICをつくっているところを見てみよう。
```
    XIC ic = XCreateIC(xim,
                        /* the following are in attr, val format, terminated by NULL */
                        XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
                        XNClientWindow, win,
                        NULL);
```
`XNInputStyle`の値として`XIMPreeditNothing | XIMStatusNothing`を指定している。この`XIMPreeditNothing`というところが仮入力状態をどう扱いたいかをしてするものである。
`XIMPreeditNothing`は仮入力状態を渡すことなく動いてしまう。そのため、代わりに`XIMPreeditCallback`を指定しなければならない。
このオプションを使う場合、クライアント側に仮入力の状態が変化した際のコールバックを`XNPreeditAttributes`として渡してあげる必要がある。
コールバックには`XNPreeditStartCallback`、`XNPreeditDoneCallback`、`XNPreeditDrawCallback`、`XNPreeditCaretCallback`の4つがある。
- `XNPreeditStartCallback`: 仮入力がスタートしたときに呼ばれる
- `XNPreeditDoneCallback`: 仮入力が終了したときに呼ばれる
- `XNPreeditDrawCallback`: 仮入力状態の文字が更新されたときに呼ばれる。呼び出されたときに変化した文字列の情報が渡されてくる。
- `XNPreeditCaretCallback`: 入力カーソルの位置が変わったときに呼ばれる。呼び出されたときに入力カーソルの位置の変化情報が渡されてくる。

これらを`XVaNestedList`型として`XNPreeditAttributes`として`XCreateIC`に渡す必要がある。各コールバックは`XIMCallback`構造体へのポインタとして定義される必要がある。
`XIMCallback`構造体の定義は以下の通りである。
```
typedef struct {
    XPointer client_data;
    XIMProc callback;
} XIMCallback;
```

XPointerは`char *`、つまり汎用のポインタで、`XIMProc`の定義は
```
typedef void (*XIMProc)(
    XIM,
    XPointer,
    XPointer
);
```
となっている。第一引数は`XIM`型となっているが、[こちらのドキュメント](https://www.x.org/releases/X11R7.5/doc/libX11/libX11.html)では`XIC`型となっている。どちらが正しいかわからないが、今回はこれは使わないのでスルー。
第二引数は`XIMCallback`の`client_data`が渡されてきて、第三引数にはコールバックの種類によって必要な情報がサーバー側から送られてくる（以後、`call_data`と呼ぶ）。`XPointer`型を適宜キャストして使うことになる。

`XNPreeditStartCallback`では`call_data`には`NULL`が渡されてくる。`XIMProc`型の関数の返り値は`void`となっているが、実際はこのコールバックは仮入力文字列の長さの上限を返さなければならない。`-1`とした場合、上限はない。
今回はこのように定義する。
```
static int preedit_start_callback(
    XIM xim,
    XPointer client_data,
    XPointer call_data)
{
    printf("preedit start\n");
    // no length limit
    return -1;
}
```

`XNPreeditDoneCallback`も`call_data`は`NULL`が渡されてくる。今回は仮入力中の文字列を出力したいだけなので、特に何もしないでいいだろう。
```
static void preedit_done_callback(
    XIM xim,
    XPointer client_data,
    XPointer call_data)
{
    printf("preedit done\n");
}
```

`XNPreeditDrawCallback`が仮入力文字列に変化が起きた場合の処理である。`call_data`は`XIMPreeditDrawCallbackStruct`構造体として渡されてくる。
```
typedef struct _XIMPreeditDrawCallbackStruct {
    int caret;		/* Cursor offset within pre-edit string */
    int chg_first;	/* Starting change position */
    int chg_length;	/* Length of the change in character count */
    XIMText *text;
} XIMPreeditDrawCallbackStruct;
```

仮入力中のすべての文字が渡されてくるのではなく、変化した文字列の情報が渡されてくる。
`chg_first`から`chg_length`文字数分が`text`に変化したという感じである。
ただし、筆者の環境のIMEは`chg_first`に常に0が渡されて、`text`に仮入力中の文字全部が渡されるような動作をした。
しかし、仕様の上では一部しか渡されてこない可能性もあるので、一応注意して実装する。
なお、文字数のカウントはバイト数ではなく、システムの文字コード（通常はUTF-8のはず）で解釈した場合の文字の数であることに注意。

`XIMText`型として文字列の情報が渡されてくる
```
typedef struct _XIMText {
    unsigned short length;
    XIMFeedback *feedback;
    Bool encoding_is_wchar;
    union {
	char *multi_byte;
	wchar_t *wide_char;
    } string;
} XIMText;
```
`encode_is_wchar`のとき、`wide_char`として文字列が来るが、今回は`multi_byte`で来る場合のみ扱う（gtkでも対応していない）。
`length`はここでもバイト数ではなく、実際の文字の数である。
`XIMFeedback`は各文字の装飾に関する情報だが、今回は割愛する。
なお、`text`は`NULL`になる場合があり、それは`chg_first`から`chg_length`までの文字が削除されたことを意味する。
C言語にはマルチバイト文字をいい感じに扱うライブラリがないため、真面目に仮入力中の文字すべてを正しく把握しようとすると結構面倒そうなので、今回は来た情報だけを標準出力に吐くだけにしておく

```
static void preedit_draw_callback(
    XIM xim,
    XPointer client_data,
    XIMPreeditDrawCallbackStruct *call_data)
{

    printf("callback\n");
    XIMText *xim_text = call_data->text;
    if (xim_text != NULL)
    {
        printf("Draw callback string: %s, length: %d, first: %d, caret: %d\n", xim_text->string.multi_byte, call_data->chg_length, call_data->chg_first, call_data->caret);
    }
    else
    {
        printf("Draw callback string: (DELETED), length: %d, first: %d, caret: %d\n", call_data->chg_length, call_data->chg_first, call_data->caret);
    }
}
```

最後の`XNPreeditCaretCallback`は`call_data`として以下のような構造体として情報が来る。
```
typedef struct _XIMPreeditCaretCallbackStruct {
    int position;		 /* Caret offset within pre-edit string */
    XIMCaretDirection direction; /* Caret moves direction */
    XIMCaretStyle style;	 /* Feedback of the caret */
} XIMPreeditCaretCallbackStruct;
```
カーソルのポジションと移動した方向、カーソルの表示の際の装飾情報が渡されてくる。文字列は変化していないので、文字列に関する情報はない。
以下のようなコールバック関数を定義しておく。
```
static void preedit_caret_callback(
    XIM xim,
    XPointer client_data,
    XIMPreeditCaretCallbackStruct *call_data)
{
    printf("preedit caret\n");
    if (call_data != NULL)
    {
        printf("direction: %d position: %d\n", call_data->direction, call_data->position);
    }
}
```

さて、これらを`XIC`をつくるときのパラメータとして渡すために、`XVaNestedList`として渡すには以下のようにする。
```
    XIMCallback draw_callback;
    draw_callback.client_data = NULL;
    draw_callback.callback = (XIMProc)preedit_draw_callback;
    XIMCallback start_callback;
    start_callback.client_data = NULL;
    start_callback.callback = (XIMProc)preedit_start_callback;
    XIMCallback done_callback;
    done_callback.client_data = NULL;
    done_callback.callback = (XIMProc)preedit_done_callback;
    XIMCallback caret_callback;
    caret_callback.client_data = NULL;
    caret_callback.callback = (XIMProc)preedit_caret_callback;
    XVaNestedList preedit_attributes = XVaCreateNestedList(
        0,
        XNPreeditStartCallback, &start_callback,
        XNPreeditDoneCallback, &done_callback,
        XNPreeditDrawCallback, &draw_callback,
        XNPreeditCaretCallback, &caret_callback,
        NULL);
```
今回は`client_data`を使わないので、`NULL`を渡しておいた。ポインタで渡しているだけなので、`XIMCallback`が`XIC`の生存中にちゃんと生きていなければならないことには注意
そして、`XIC`をつくる部分のコードを以下のように書き換える。

```
    XIC ic = XCreateIC(xim,
                       XNInputStyle, XIMPreeditCallbacks | XIMStatusNothing,
                       XNClientWindow, win,
                       XNPreeditAttributes, preedit_attributes,
                       NULL);
```

完成品はこちら
{% linkPreview  https://gist.github.com/garasubo/8ebb893f2af1950254df715fcf1de58e _blank %}


実行例:
```
preedit start
callback
Draw callback string: あ, length: 0, first: 0, caret: 1
callback
Draw callback string: あい, length: 1, first: 0, caret: 2
callback
Draw callback string: あいう, length: 2, first: 0, caret: 3
callback
Draw callback string: あいうえ, length: 3, first: 0, caret: 4
callback
Draw callback string: あいうえお, length: 4, first: 0, caret: 5
delievered string: あいうえお
callback
Draw callback string: (DELETED), length: 5, first: 0, caret: 0
preedit done
preedit start
callback
Draw callback string: お, length: 0, first: 0, caret: 1
callback
Draw callback string: おｎ, length: 1, first: 0, caret: 2
callback
Draw callback string: おの, length: 2, first: 0, caret: 2
callback
Draw callback string: おのｒ, length: 2, first: 0, caret: 3
callback
Draw callback string: おのれ, length: 3, first: 0, caret: 3
callback
Draw callback string: おのれｎ, length: 3, first: 0, caret: 4
callback
Draw callback string: おのれの, length: 4, first: 0, caret: 4
callback
Draw callback string: おのれのｆ, length: 4, first: 0, caret: 5
callback
Draw callback string: おのれのふ, length: 5, first: 0, caret: 5
callback
Draw callback string: おのれのふｇ, length: 5, first: 0, caret: 6
callback
Draw callback string: おのれのふが, length: 6, first: 0, caret: 6
callback
Draw callback string: おのれのふがｋ, length: 6, first: 0, caret: 7
callback
Draw callback string: おのれのふがく, length: 7, first: 0, caret: 7
callback
Draw callback string: おのれのふがくｗ, length: 7, first: 0, caret: 8
callback
Draw callback string: おのれのふがくを, length: 8, first: 0, caret: 8
callback
Draw callback string: 己の富嶽を, length: 8, first: 0, caret: 0
callback
Draw callback string: 己の富嶽を, length: 5, first: 0, caret: 2
callback
Draw callback string: 己の富嶽を, length: 5, first: 0, caret: 0
callback
Draw callback string: おのれの富嶽を, length: 5, first: 0, caret: 0
callback
Draw callback string: 己の富嶽を, length: 7, first: 0, caret: 0
callback
Draw callback string: 己の富嶽を, length: 5, first: 0, caret: 2
callback
Draw callback string: 己の富岳を, length: 5, first: 0, caret: 2
callback
Draw callback string: 己のフガクを, length: 5, first: 0, caret: 2
callback
Draw callback string: 己の不学を, length: 6, first: 0, caret: 2
delievered string: 己の不学を
callback
Draw callback string: (DELETED), length: 5, first: 0, caret: 0
preedit done
```

## リファレンス
一応、以上の仕様は以下のドキュメントにあるのだが、かなり古く読みにくい

概念的な話はこちら。正直、読み方がわからなかった
{% linkPreview https://www.x.org/releases/X11R7.6/doc/libX11/specs/XIM/xim.html _blank %}

こっちはXlibの実装の解説ではあるが、レイアウトがメチャクチャである

[Xlib − C Language X Interface](https://www.x.org/releases/X11R7.5/doc/libX11/libX11.html)

結局GTKの実装を参照するほうが楽であったが、GTK4（まだリリースはされていない）の最新版ではなんとXIMのサポートが削除されている。
{% linkPreview https://gitlab.gnome.org/GNOME/gtk/merge_requests/1195 _blank %}
GTK3までならちゃんと生きているので、そちらを参考にすると良い
{% linkPreview https://gitlab.gnome.org/GNOME/gtk/blob/3.24.13/modules/input/gtkimcontextxim.c _blank %}